{"version":3,"sources":["src/data-operations/sorting-strategy.ts"],"names":[],"mappings":"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","file":"sorting-strategy.js","sourcesContent":["import { ISortingExpression, SortingDirection } from \"./sorting-expression.interface\";\r\n\r\nexport interface ISortingStrategy {\r\n    sort: (data: any[], expressions: ISortingExpression[]) => any[];\r\n    compareValues: (a: any, b: any) => number;\r\n}\r\n\r\nexport class SortingStrategy implements ISortingStrategy {\r\n    public sort(data: any[], expressions: ISortingExpression[]): any[] {\r\n        return this.sortDataRecursive(data, expressions);\r\n    }\r\n    public compareValues(a: any, b: any) {\r\n        const an = (a === null || a === undefined);\r\n        const bn = (b === null || b === undefined);\r\n        if (an) {\r\n            if (bn) {\r\n                return 0;\r\n            }\r\n            return -1;\r\n        } else if (bn) {\r\n            return 1;\r\n        }\r\n        return a > b ? 1 : a < b ? -1 : 0;\r\n    }\r\n    protected compareObjects(obj1: object, obj2: object, key: string, reverse: number, ignoreCase: boolean) {\r\n        let a = obj1[key];\r\n        let b = obj2[key];\r\n        if (ignoreCase) {\r\n            a = a && a.toLowerCase ? a.toLowerCase() : a;\r\n            b = b && b.toLowerCase ? b.toLowerCase() : b;\r\n        }\r\n        return reverse * this.compareValues(a, b);\r\n    }\r\n    protected arraySort<T>(data: T[], compareFn?): T[] {\r\n        return data.sort(compareFn);\r\n    }\r\n    private groupedRecordsByExpression<T>(data: T[], index: number, expression: ISortingExpression): T[] {\r\n        let i;\r\n        let groupval;\r\n        const res = [];\r\n        const key = expression.fieldName;\r\n        const len = data.length;\r\n        const cmpFunc = (val1, val2): boolean => {\r\n            return val1 === val2;\r\n        };\r\n        res.push(data[ index ]);\r\n        groupval = data[ index ][ key ];\r\n        index++;\r\n        for (i = index; i < len; i++) {\r\n            if (cmpFunc(data[ i ][ key ], groupval)) {\r\n                res.push(data[ i ]);\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n    private sortByFieldExpression<T>(data: T[], expression: ISortingExpression): T[] {\r\n\r\n        const key = expression.fieldName;\r\n        const ignoreCase = expression.ignoreCase ?\r\n                            data[0] && (typeof data[0][key] === \"string\" ||\r\n                                               data[0][key] === null ||\r\n                                               data[0][key] === undefined) :\r\n                            false;\r\n        const reverse = (expression.dir === SortingDirection.Desc ? -1 : 1);\r\n        const cmpFunc = (obj1, obj2) => {\r\n            return this.compareObjects(obj1, obj2, key, reverse, ignoreCase);\r\n        };\r\n        return this.arraySort(data, cmpFunc);\r\n    }\r\n\r\n    private sortDataRecursive<T>(data: T[],\r\n                                 expressions: ISortingExpression[],\r\n                                 expressionIndex: number = 0): T[] {\r\n        let i;\r\n        let j;\r\n        let expr;\r\n        let gbData;\r\n        let gbDataLen;\r\n        const exprsLen = expressions.length;\r\n        const dataLen = data.length;\r\n        expressionIndex = expressionIndex || 0;\r\n        if (expressionIndex >= exprsLen || dataLen <= 1) {\r\n            return data;\r\n        }\r\n        expr = expressions[ expressionIndex ];\r\n        data = this.sortByFieldExpression(data, expr);\r\n        if (expressionIndex === exprsLen - 1) {\r\n            return data;\r\n        }\r\n        // in case of multiple sorting\r\n        for (i = 0; i < dataLen; i++) {\r\n            gbData = this.groupedRecordsByExpression(data, i, expr);\r\n            gbDataLen = gbData.length;\r\n            if (gbDataLen > 1) {\r\n                gbData = this.sortDataRecursive(gbData, expressions, expressionIndex + 1);\r\n            }\r\n            for (j = 0; j < gbDataLen; j++) {\r\n                data[ i + j ] = gbData[ j ];\r\n            }\r\n            i += gbDataLen - 1;\r\n        }\r\n        return data;\r\n    }\r\n}\r\n"]}